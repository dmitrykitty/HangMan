"CRTP","Curiously Recurring Template Pattern: an idiom where a class (usually a base class) is templated on a derived class and the derived class passes itself as the template parameter. This allows static polymorphism and code reuse at compile time.","hard"
"PIMPL","Pointer to Implementation (also known as the pimpl idiom): a design pattern where a class holds a pointer to an struct/class (the 'impl') that contains the actual implementation. It helps to reduce compile-time dependencies and to provide binary compatibility by hiding implementation details behind an interface.","hard"
"POD","Plain Old Data: a term for C++ types that have a memory layout compatible with C structs (pre C++11 definition). Generally means no user-defined constructors, destructors, or virtual methods, and only public data. In C++11 and later, the concept is replaced by trivial and standard-layout types.","hard"
"RAII","Resource Acquisition Is Initialization: an idiom where resource allocation is tied to object lifetime. Resources (memory, file handles, etc.) are acquired in a constructor and released in the destructor, ensuring proper cleanup automatically.","hard"
"RTTI","Run-Time Type Information: mechanisms that allow type information to be available at runtime (e.g., typeid operator yielding a std::type_info, dynamic_cast for safely downcasting polymorphic pointers).","hard"
"SFINAE","Substitution Failure Is Not An Error: a C++ template rule that if substituting template arguments into a template leads to an invalid construct, the compiler doesn't immediately error, but instead treats that template specialization as not viable, allowing overload resolution to continue (commonly exploited in template metaprogramming).","hard"
"dynamic_cast","A cast used primarily for safely downcasting pointers or references in an inheritance hierarchy. Returns nullptr (for pointers) or throws bad_cast (for references) if the object is not of the target type.","hard"
"explicit","Prevents implicit conversions for a constructor or operator (must be used explicitly).","hard"
"final","A specifier indicating that a class cannot be derived from or that a virtual function cannot be overridden in derived classes (C++11).","hard"
"inline_namespace","A namespace declared with the inline keyword (C++11). Members of an inline namespace are treated as if they belong to the enclosing namespace for linkage and lookup. This is often used for versioning libraries while maintaining ABI compatibility.","hard"
"mutable","Allows a class member to be modified even if the object is const.","hard"
"noexcept","Specifies that a function does not throw exceptions (or will terminate if one is thrown).","hard"
"override","Specifies that a virtual function overrides a base class method (C++11).","hard"
"perfect_forwarding","The ability of a template function to forward arguments to another function such that lvalues are passed as lvalues and rvalues as rvalues. Achieved using forwarding references (universal references) and std::forward.","hard"
"register","Suggests to the compiler to use a CPU register for the variable (mostly ignored now).","hard"
"reinterpret_cast","A cast that reinterprets the raw bits of one pointer or integral type as another type. Used for low-level casts (e.g., between incompatible pointer types).","hard"
"requires","Introduces template constraints or a requires clause in a concept definition (C++20).","hard"
"static_assert","Checks a condition at compile time and produces a compile error if false (C++11).","hard"
"static_binding","Also known as early binding. Function calls and overload resolution decisions that are made at compile time (e.g., calling non-virtual functions or overloaded functions chosen by static types).","hard"
"strict_aliasing","A rule in C++ (inherited from C) that assumes pointers of different types (except certain exceptions) do not point to the same memory. Violating this rule (type-punning without proper methods) leads to undefined behavior but allows compilers to optimize based on the assumption.","hard"
"template_metaprogramming","Using C++ template mechanism to perform computations or generate types at compile time. It treats templates as a kind of compile-time code (e.g., using recursion on templates to compute a factorial at compile time).","hard"
"template_argument_deduction","The process by which the compiler determines template arguments from the function call or initialization context. For example, with template<class T> void f(T x); calling f(5) deduces T=int.","hard"
"template_template_parameter","A template parameter that itself is a template. For example, in template<template<typename> class Container>, Container is a template template parameter that could match std::vector, std::list, etc.","hard"
"two_phase_lookup","The name lookup process for templates which occurs in two phases: first, names not dependent on template parameters are resolved at template definition; second, dependent names are resolved at template instantiation. This can affect how templates are written and when errors are reported.","hard"
"type_erasure","An idiom to abstract away concrete types behind a uniform interface, typically by storing them in a wrapper that uses inheritance or templates like std::any or std::function so that code using them need not be template.","hard"
"type_punning","Treating a data of one type as if it were a data of another type, often by reinterpretation through a union or pointer cast. It can violate strict aliasing rules if not done carefully (e.g., using std::memcpy is a safe way to avoid aliasing issues).","hard"
"undefined_behavior","Program behavior that is not defined by the C++ standard, often leading to unpredictable results (should be avoided).","hard"
"virtual_destructor","A destructor declared with the virtual keyword. It ensures that the destructor of the derived class is called when an object is deleted through a pointer to a base class. Needed for proper cleanup in polymorphic base classes.","hard"
"virtual_inheritance","A form of inheritance used to avoid duplicate base class subobjects when using multiple inheritance (the 'diamond problem'). A virtually inherited base class is shared among all derived classes, ensuring only one base subobject exists.","hard"
"vtable","Virtual table: an internal lookup table used by C++ implementations to support dynamic dispatch (virtual functions). It holds function pointers for an object's virtual functions. Each polymorphic class typically has a single vtable, and each object has a hidden pointer (vptr) to its class's vtable.","hard"
"xvalue","Expiring value, an rvalue that denotes an object near the end of its lifetime (e.g., the result of std::move). It can be moved from. Xvalues are a subset of glvalues (because they have identity but can be treated as rvalues for moving).","hard"
